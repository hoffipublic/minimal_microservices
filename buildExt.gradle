
// for other domain specific buildfiles look inside the buildfiles/ subdirectory

configure(project.rootProject) {
    // project.ext.set('branch', gitBranch) and project.ext.set('commit', gitCommit)
    determineCurrentGitBranchAndLastCommitHash()
    ext {
        versionBranchStatusHash = {
            versionBranchStatusJson = """{
                "master":  { "version": "0.1.0", "status": "RELEASE",   "publishRepoKey" : "libs-release" },
                "develop": { "version": "0.1.0", "status": "NIGHTLY",   "publishRepoKey" : "libs-snapshot" },
                "release": { "version": "0.1.0", "status": "MILESTONE", "publishRepoKey" : "libs-snapshot" },
                "hotfix":  { "version": "0.1.0", "status": "HOTFIX",    "publishRepoKey" : "libs-release" },
                "support": { "version": "0.1.0", "status": "SUPPORT",   "publishRepoKey" : "libs-release" },
                }"""
                // else FEATURE (see below)
            def slurper = new groovy.json.JsonSlurper()
            return slurper.parseText(project.ext.versionBranchStatusJson)
        }

        if ( versionBranchStatusHash()[branch] != null) {
            versionBase = versionBranchStatusHash()[branch]["version"]
            status = versionBranchStatusHash()[branch]["status"]
        } else {
            versionBase = versionBranchStatusHash()["develop"]["version"]
            status = "FEATURE"
        }
        version = "${versionBase}.${status}"
        springProfilesActive = System.env.SPRING_PROFILES_ACTIVE == null ? ["default"]: System.env.SPRING_PROFILES_ACTIVE.split(',')
    }
}

task branchVersionsPrint(group:project.rootProject.ext.group, description:"current mapping of git branches to release versions (in buildExt.gradle)") {
    doLast {
        println "git branch to version status from buildExt.gradle:"
        versionBranchStatusHash().each{ branch, map -> println("branch: " + branch.padRight(7) + " ${map["version"]}.${map["status"]}")}
        println "\ncurrent git branch was ${project.ext.branch} (commit: ${project.ext.commit}) --> jar postfix: ${project.rootProject.ext.version}.jar"
    }
}

def determineCurrentGitBranchAndLastCommitHash() {
    def gitBranch = "master"
    def gitCommit = "none"

    def gitFolderName = "$projectDir/.git/"
    def gitFolder = new File(gitFolderName)
    def gitHead = new File(gitFolder, "HEAD")
    if (gitFolder.exists() && gitFolder.isDirectory() && gitHead.exists()) {
	    /*
	     * '.git/HEAD' contains either
	     *      in case of detached head: the currently checked out commit hash
	     *      otherwise: a reference to a file containing the current commit hash
	     */
	    def head = gitHead.text.split(":") // .git/HEAD
	    def isCommit = head.length == 1 // e5a7c79edabbf7dd39888442df081b1c9d8e88fd
	    // def isRef = head.length > 1     // ref: refs/heads/master
	
	    if(isCommit) {
	        gitCommit = head[0].trim().take(12) // e5a7c79edabb
	        gitBranch = gitCommit
	    } else {
	        def refHead = new File(gitFolderName + head[1].trim()) // .git/refs/heads/master
	        if (refHead.exists()) {
		        gitCommit = refHead.text.trim().take 12
		        def s = head[1].trim()
		        // everything after the second / up to the end with slashes replaced by underscore
		        gitBranch = s.substring(s.indexOf('/', s.indexOf('/') + 1) + 1).replace('/', '_')
		    }
	    }
    }

    project.ext.set('branch', gitBranch)
    project.ext.set('commit', gitCommit)
    println "currentGitBranch: '${project.ext.branch}' (commit: ${project.ext.commit})"
    if (project.ext.branch == "") {  throw new GradleException("cannot determine local git branch")  }

}
