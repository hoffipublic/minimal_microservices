import org.springframework.cloud.contract.verifier.config.TestFramework
import org.gradle.internal.logging.text.StyledTextOutput 
import org.gradle.internal.logging.text.StyledTextOutputFactory
import org.gradle.internal.logging.text.StyledTextOutput.Style

project.ext.archiveBaseName = 'minimal_microservice' // also used as artifactId in buildfiles/buildArtifactory.gradle
// archive(s!!!)BaseName
project.archivesBaseName = project.ext.archiveBaseName
group = project.rootProject.ext.group
version = project.rootProject.ext.version
project.ext.port = 8761 // this must match the port set in src/main/resources/bootstrap.yml

dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-security'
    implementation "org.springframework.boot:spring-boot-starter-actuator"
    annotationProcessor "org.springframework.boot:spring-boot-configuration-processor" // for @ConfigurationProperties, make sure compileJava.dependsOn(processResources)

    implementation "org.springframework.boot:spring-boot-starter-web"
    implementation "org.springframework.cloud:spring-cloud-starter"

    implementation 'org.springframework.boot:spring-boot-starter-aop'
    //implementation "org.springframework.cloud:spring-cloud-starter-circuitbreaker-resilience4j:${vs('springCloudCircuitbreakerSnapshotVersion')}"
    // implementation "io.github.resilience4j:resilience4j-spring-boot2:${v('resilience4jVersion')}"
    implementation "io.github.resilience4j:resilience4j-spring-cloud2:${v('resilience4jVersion')}"
    implementation "io.github.resilience4j:resilience4j-circuitbreaker:${v('resilience4jVersion')}"
    implementation "io.github.resilience4j:resilience4j-timelimiter:${v('resilience4jVersion')}"

    implementation "io.github.resilience4j:resilience4j-micrometer:${v('resilience4jVersion')}"
    implementation "io.github.resilience4j:resilience4j-prometheus:${v('resilience4jVersion')}"

    // implementation "io.opentracing.brave:brave-opentracing"

    implementation "io.zipkin.brave:brave:5.9.1"
    implementation "io.zipkin.brave:brave-instrumentation-http:5.9.1"
    implementation "io.zipkin.brave:brave-instrumentation-httpclient:5.9.1"
    implementation "io.zipkin.brave:brave-instrumentation-spring-rabbit:5.9.1"
    implementation "io.zipkin.brave:brave-instrumentation-spring-web:5.9.1"
    implementation "io.zipkin.brave:brave-instrumentation-spring-webmvc:5.9.1"
    implementation "io.zipkin.brave:brave-instrumentation-servlet:5.9.1"
	implementation 'org.springframework.cloud:spring-cloud-sleuth-core'+":${vs('springSleuthVersion')}" // zipkin'
	implementation 'org.springframework.cloud:spring-cloud-sleuth-zipkin'+":${vs('springSleuthVersion')}" // zipkin'
	implementation 'org.springframework.cloud:spring-cloud-starter-sleuth'+":${vs('springSleuthVersion')}" // zipkin'
	implementation 'org.springframework.cloud:spring-cloud-starter-zipkin'+":${vs('springSleuthVersion')}" // zipkin'

    runtimeOnly "io.micrometer:micrometer-registry-prometheus:${v('micrometerRegistryPrometheusVersion')}"

    // implementation "io.zipkin.reporter2:zipkin-sender-amqp-client:2.10.3"
    implementation "io.zipkin.reporter2:zipkin-reporter:2.10.3"


    // // implementation 'org.springframework.cloud:spring-cloud-starter-sleuth' // if using without zipkin
    // implementation 'org.springframework.cloud:spring-cloud-starter-zipkin'
    // implementation 'org.springframework.cloud:spring-cloud-sleuth-zipkin'
    // // // jaeger might be a replacement for sleuth and zipkin (obove) as soon as they support traceContext within slf4j MDC
    // // implementation "io.jaegertracing:jaeger-client:${v('jaegerClientVersion')}"
    // // implementation "io.opentracing.contrib:opentracing-spring-jaeger-cloud-starter:${v('springJaegerCloud')}"
    implementation "io.zipkin.brave:brave-instrumentation-spring-rabbit"
    
    //implementation "org.springframework.cloud:spring-cloud-starter-circuitbreaker-resilience4j:${versions.latest.snapshots['springCloudCircuitbreakerSnapshotVersion']}"


    implementation 'org.springframework.cloud:spring-cloud-stream'
    //implemenentation "org.springframework.cloud:spring-cloud-starter-stream-rabbit"
    implementation 'org.springframework.amqp:spring-rabbit'
    implementation 'org.springframework.cloud:spring-cloud-stream-binder-rabbit'

    // implementation 'org.springframework.cloud:spring-cloud-starter-netflix-hystrix'

    // spring-boot-starter-test already includes the following provided libraries
    // AssertJ
    // Hamcrest
    // Mockito
    // JSONassert
    // JsonPath
    testImplementation("org.springframework.boot:spring-boot-starter-test")
    testImplementation("org.springframework.security:spring-security-test")
    testImplementation("org.junit.jupiter:junit-jupiter-api")
    testImplementation("org.junit.jupiter:junit-jupiter-params")
    testRuntimeOnly("org.junit.jupiter:junit-jupiter-engine")
    testImplementation('org.springframework.cloud:spring-cloud-stream-test-support') // messaging test support for spring-cloud-stream
    // spring-cloud-contract
    // API implementor (procucer) side
    testImplementation("org.springframework.cloud:spring-cloud-starter-contract-verifier:${vs('springCloudContractVersion')}")
    // API consumer (client) side
    testImplementation("org.springframework.cloud:spring-cloud-starter-contract-stub-runner:${vs('springCloudContractVersion')}")

    testImplementation(
    // localGroovy(), // use gradles internal version of groovy
        "org.codehaus.groovy:groovy-all:${versions.latest.groovy['groovyAllVersion']}",
        "org.spockframework:spock-core:${versions.latest.groovy['spockVersion']}",
        "org.spockframework:spock-spring:${versions.latest.groovy['spockVersion']}",
    )
//    testCompile("de.demo:minimal_microservices:${version}:stubs") {
//        transitive = false
//    }
}
// configurations {
//     contracts {
//         transitive = false
//     }
// }

compileJava.dependsOn(processResources)

apply plugin: 'maven-publish'
apply plugin: 'com.jfrog.artifactory'
//apply plugin: 'com.terrafolio.jenkins'

apply plugin: 'cloudfoundry'
//apply plugin: 'docker'
apply from: project.rootProject.projectDir.toString() + '/buildfiles/buildEnv.gradle' // read environments.config
apply from: project.rootProject.projectDir.toString() + '/buildfiles/buildCf.gradle'  // showCfTargetAndLogin, showCfCmds and generateCfCmds
//apply from: project.rootProject.projectDir.toString() + '/buildfiles/buildDocker.gradle'
apply from: project.rootProject.projectDir.toString() + '/buildfiles/buildArtifactory.gradle'
//apply from: project.rootProject.projectDir.toString() + '/buildfiles/buildJenkins.gradle'
apply from: project.rootProject.projectDir.toString() + '/buildfiles/buildMisc.gradle' // showBootRunCommand

apply from: project.rootProject.projectDir.toString() + '/buildfiles/buildSpringConfig.gradle'
apply from: project.rootProject.projectDir.toString() + '/buildfiles/buildVscode.gradle'

publishing {
    // gradle publishToMavenLocal
    // find ~/.m2/repository -type f -name '*microservices*' | xargs ls -lh | sed -E 's/^(.*) \/.*\.m2\/repository\/(.*)/\1 \2/'
    publications {
        maven(MavenPublication) {
            groupId = groupId
            artifactId = project.ext.archiveBaseName
            version = version

            from components.java
        }
		stubs(MavenPublication) {
			//artifactId "${archiveBaseName}-stubs"
			artifactId project.ext.archiveBaseName
			artifact verifierStubsJar
		}
    }
    //   repositories {
    //        maven {
    //            credentials { ... }
    //
    //            if (project.version.endsWith('-SNAPSHOT'))
    //                url "http://localhost:8081/artifactory/libs-snapshot-local"
    //            else
    //                url "http://localhost:8081/artifactory/libs-release-local"
    //        }
    //    }
    
}
build.finalizedBy publishToMavenLocal // push jars to mavenLocal after build

// whatIsPublished(group:publishing, description:"what is published to maven repo") {
//    doLast {
//    find /Users/hoffmd9/.m2/repository -type f -name '*minimal_microservicess*' | xargs ls -l
//    }
//}
//publishToMavenLocal.finalizedBy whatIsPublished
//publishPubNamePublicationToMavenLocal.finalizedBy whatIsPublished

contracts {
    targetFramework = TestFramework.JUNIT5
    baseClassForTests = 'com.hoffi.minimal.microservices.microservice.contractbaseclasses.DefaultBaseClass'
    baseClassMappings {
        // matching path below src/test/resources/contracts/
		baseClassMapping('.*inbound.*', 'com.hoffi.minimal.microservices.microservice.contractbaseclasses.SinkBaseClass')
		baseClassMapping('.*outbound.*', 'com.hoffi.minimal.microservices.microservice.contractbaseclasses.SourceBaseClass')
	}
    // // Creates an array with static imports that should be included in generated tests(for example ['org.myorg.Matchers.*']). By default, it creates an empty array
    // staticImports = ['org.myorg.Matchers.*']
    // // the following properties are used when you want to provide where the JAR with contract lays
    // contractDependency {
    //     stringNotation = ''
    // }

    // contractsPath = ''
    // contractsWorkOffline = false
}

compileJava {
    // options.compilerArgs += ["--add-modules", "java.xml.bind"]
    println "Gradle version: " + project.getGradle().getGradleVersion()
    println "Groovy version: " + GroovySystem.getVersion()
    println "javac  version: " + org.gradle.internal.jvm.Jvm.current() + ' with compiler args: ' + options.compilerArgs
    println "boot   version: " + v('springBootVersion')
    println "cloud  version: " + v('springCloudVersion')
    
}
//compileTestJava {
//    // options.compilerArgs += ["--add-modules", "java.xml.bind"]
//  println 'compileTestJava with version ' + org.gradle.internal.jvm.Jvm.current() + ' with compiler args: ' + options.compilerArgs
//}

springBoot {
    mainClassName = "com.hoffi.minimal.microservices.microservice.MicroserviceApplication"

    // This statement tells the Gradle Spring Boot plugin to generate a file
    // build/resources/main/META-INF/build-info.properties
    // that is picked up by Spring Boot to display via actuator /info endpoint.
    buildInfo {
        properties {
            // Generate extra build info.
            additional = additionalBuildInfo(project) // from buildfiles/buildMisc.gradle
        }
    }
}

compileJava.dependsOn(processResources)

bootJar {
    launchScript() // make the fat.jar executable (e.g. for sudo ln -s /var/myapp/myapp.jar /etc/init.d/myapp)
    doLast {
        println "${project.group}:${project.archivesBaseName}:${project.version} ==> ./build/libs/" + jar.archivePath.name
    }
}

bootRun { systemProperties = System.properties } // ensure Gradle passes command line arguments to the JVM

jar {
    //archiveBaseName = project.ext.archiveBaseName = project.archivesBaseName // latter with "s" archive(s)!!!
    // archiveVersion = project.rootProject.ext.version
    manifest {
        attributes 'Implementation-Title' : project.ext.archiveBaseName,
                   'Implementation-Version' : project.rootProject.ext.version,
                   'provider': 'gradle'
    }
}

// Once we call ./gradlew generateContractTests
// the Spring Cloud Contract Gradle plugin will now generate a JUnit test in the folder build/generated-test-sources
// and ./gradlew publishToMavenLocal
test {
    useJUnitPlatform {
//        includeTags 'fast'
//        excludeTags 'app', 'integration', 'messaging', 'slow', 'trivial'
    }
    failFast = false
    ignoreFailures true
    reports.html.enabled = false

    testLogging {
        showStandardStreams = false
        exceptionFormat = 'full'
        events "PASSED", "FAILED", "SKIPPED" //, "STARTED" //, "standardOut", "standardError"
    }

    beforeTest { descriptor ->
        logger.lifecycle("Running " + descriptor)
    }
    // listen to standard out and standard error of the test JVM(s)
    onOutput { descriptor, event ->
        // logger.lifecycle("Test: " + descriptor + " produced standard out/err: " + event.message )
        event.message
    }
    afterSuite { desc, result ->
        if (!desc.parent) { // will match the outermost suite
            def out = services.get(StyledTextOutputFactory).create("an-ouput")
            if (result.failedTestCount <= 0) {
                out.style(Style.Success).println "\nTest Results: ${result.resultType} (${result.testCount} tests, ${result.successfulTestCount} successes, ${result.failedTestCount} failures, ${result.skippedTestCount} skipped)"
            } else {
                out.style(Style.Failure).println "\nTest Results: ${result.resultType} (${result.testCount} tests, ${result.successfulTestCount} successes, ${result.failedTestCount} failures, ${result.skippedTestCount} skipped)"
            }
        }
    }
}

clean.doFirst {
    // delete "~/.m2/repository/com/example/http-server-dsl-gradle"
}
